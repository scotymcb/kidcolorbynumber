// js/image-processor.js

/**
 * The main image processing function.
 * Takes an image data URL and configuration, returns processed project data.
 * @param {string} imageDataUrl - The base64 data URL of the source image.
 * @param {object} config - The global configuration object from app.js.
 * @returns {Promise<object>} A promise that resolves with the processed project data.
 */
async function processImage(imageDataUrl, config) {
    // Step 1: Resize the image to a manageable dimension for performance.
    const resizedImageData = await resizeImage(imageDataUrl, config.maxImageDimension);

    // Step 2: Use imagetracer.js to perform color quantization and vector tracing.
    // imagetracerjs handles both reducing the color palette and converting the
    // pixel-based image into SVG paths in one step.
    return new Promise((resolve, reject) => {
        ImageTracer.imageToSVG(
            resizedImageData.url,
            (svgString) => {
                // Step 3: Post-process the SVG to make it interactive.
                const processedData = postProcessSvg(svgString, resizedImageData.palette);
                resolve(processedData);
            },
            config.imageTraceOptions // Use options from the main config
        );
    });
}

/**
 * Resizes an image using an offscreen canvas.
 * @param {string} imageDataUrl - The source image data URL.
 * @param {number} maxDim - The maximum width or height for the resized image.
 * @returns {Promise<{url: string, palette: Array}>} An object with the resized data URL and the generated palette.
 */
function resizeImage(imageDataUrl, maxDim) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            let { width, height } = img;
            if (width > height) {
                if (width > maxDim) {
                    height *= maxDim / width;
                    width = maxDim;
                }
            } else {
                if (height > maxDim) {
                    width *= maxDim / height;
                    height = maxDim;
                }
            }
            canvas.width = width;
            canvas.height = height;

            ctx.drawImage(img, 0, 0, width, height);
            
            // Note: We're letting ImageTracer create the palette from the resized image.
            // This is simpler than a separate k-means step and works well.
            const palette = ImageTracer.getpalette(ctx.getImageData(0, 0, width, height));

            resolve({
                url: canvas.toDataURL('image/png'),
                palette: palette
            });
        };
        img.onerror = reject;
        img.src = imageDataUrl;
    });
}

/**
 * Cleans the SVG from imagetracer, assigns numbers to each region,
 * and builds the color-to-number mapping.
 * @param {string} svgString - The raw SVG string from ImageTracer.
 * @param {Array} rawPalette - The palette generated by ImageTracer.
 * @returns {object} The final project data object.
 */
function postProcessSvg(svgString, rawPalette) {
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
    const svgElement = svgDoc.documentElement;
    const paths = svgElement.querySelectorAll('path');

    // Create a clean, final palette and a map from original color to final index.
    const finalPalette = [];
    const colorMap = new Map();

    rawPalette.forEach(p => {
        const colorString = `rgb(${p.r},${p.g},${p.b})`;
        if (!colorMap.has(colorString)) {
            finalPalette.push(colorString);
            colorMap.set(colorString, finalPalette.length - 1);
        }
    });

    // Add numbers inside each path.
    paths.forEach((path, index) => {
        const fillColor = path.getAttribute('fill');
        const paletteIndex = colorMap.get(fillColor);
        path.setAttribute('id', `region-${index}`);
        path.setAttribute('data-color-index', paletteIndex);

        // Set initial fill to white for the coloring book effect.
        path.setAttribute('fill', '#FFFFFF');

        // Add a number label in the center of the path's bounding box.
        const bbox = path.getBBox();
        const x = bbox.x + bbox.width / 2;
        const y = bbox.y + bbox.height / 2;

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'middle');
        text.setAttribute('font-size', '12'); // Adjust size as needed
        text.setAttribute('fill', '#333');
        text.setAttribute('pointer-events', 'none'); // Make text non-interactive
        text.textContent = paletteIndex + 1; // Display 1-based number

        svgElement.appendChild(text);
    });

    return {
        svg: svgElement.outerHTML,
        palette: finalPalette,
        // We don't need a separate mapping because the data is on the path elements
    };
}
